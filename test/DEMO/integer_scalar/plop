[kernel] preprocessing with "gcc -C -E -I.  main.c"
Current project name is : default 
File name provided by the Kernel.Files.get function is main.c 
SLOCAL [ __retres:int ] = 
 
flatac_visitor: Index of global types :  
[get°entry_point_from_fundec ]  New absdom : $\Formula{\texttt{true}}{\Emp}$ 
[get°entry_point_from_fundec ]  Absdom after registering slocals : $\Formula{\texttt{true}}{\Emp}$ 
[get°entry_point_from_fundec ]  Absdom after registering sformals : $\Formula{\texttt{true}}{\Emp}$ 
[ Extended cfg Adding : Ecfg node id  : -2, Framac sid 0 ] 
 [FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar Mult(5,Mult(PlusA(Var x : int,12) : int,PlusA(PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(PlusA(Var x : int,12) : int,PlusA(PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int,1) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int,1) : int 
5 * ((x + 12) * ((3 * y + 7 * z) + 1))(x + 12) * ((3 * y + 7 * z) + 1)
(3 * y + 7 * z) + 1In cil_expr_2_scalar 1 
1In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int 
In cil_expr_2_scalar Mult(7,Var z : int) : int 
3 * y + 7 * zIn cil_expr_2_scalar Var z : int 
7 * zzIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(Var x : int,12) : int 
In cil_expr_2_scalar 12 
x + 1212In cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(5,Mult(PlusA(Var x : int,12) : int,PlusA(PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int,1) : int) : int) : int 
5 * ((x + 12) * (
                                                              (3 * y + 7 * z) + 1))In cil_expr_2_scalar Mult(PlusA(Var x : int,12) : int,PlusA(PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int,1) : int) : int 

(x + 12) * ((3 * y + 7 * z) + 1)In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int,1) : int 
In cil_expr_2_scalar 1 
(3 * y + 7 * z) + 11In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Mult(7,Var z : int) : int) : int 
In cil_expr_2_scalar Mult(7,Var z : int) : int 
3 * y + 7 * zIn cil_expr_2_scalar Var z : int 
7 * zzIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 

3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(Var x : int,12) : int 
In cil_expr_2_scalar 12 
x + 1212In cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5[ Extended cfg Adding : Ecfg node id  : 46, Framac sid 1 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar Var __retres : int 
__retres[ Extended cfg Adding : Ecfg node id  : 47, Framac sid 2 ] 
 Scheduling another vertex for execution 
SLOCAL [ __retres:int ] = 
SLOCAL [ p:int ] = 
SLOCAL [ n:int ] = 
SLOCAL [ m:int ] = 
 
flatac_visitor: Index of global types :  
[get°entry_point_from_fundec ]  New absdom : $\Formula{\texttt{true}}{\Emp}$ 
[get°entry_point_from_fundec ]  Absdom after registering slocals : $\Formula{\texttt{true}}{\Emp}$ 
[get°entry_point_from_fundec ]  Absdom after registering sformals : $\Formula{\texttt{true}}{\Emp}$ 
[ Extended cfg Adding : Ecfg node id  : -2, Framac sid 0 ] 
 [FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar 0 
0In cil_expr_2_scalar 0 
0[ Extended cfg Adding : Ecfg node id  : 49, Framac sid 1 ] 
 Scheduling another vertex for execution 
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[ Extended cfg Adding : Ecfg node id  : 50, Framac sid 2 ] 
 Scheduling another vertex for execution 
 Warning : Not a basic instruction : IfIn file : main.c, from line 8 col 9 to line 8 col 14. /n 
[ Extended cfg Adding : Ecfg node id  : 51, Framac sid 3 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar 0 
0In cil_expr_2_scalar Var x : int 
x Warning : Not a basic instruction : Block 
 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 8 col 2 to line 16 col 3. /n 
[ Extended cfg Adding : Ecfg node id  : 53, Framac sid 4 ] 
 Scheduling another vertex for execution 
[ Extended cfg Adding : Ecfg node id  : 52, Framac sid 5 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar 0 
0In cil_expr_2_scalar Var x : int 
x Warning : Not a basic instruction : Block 
 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : IfIn file : main.c, from line 9 col 8 to line 9 col 15. /n 
[ Extended cfg Adding : Ecfg node id  : 54, Framac sid 6 ] 
 Scheduling another vertex for execution 
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3[ Extended cfg Adding : Ecfg node id  : 59, Framac sid 7 ] 
 Scheduling another vertex for execution 
 Warning : Not a basic instruction : IfIn file : main.c, from line 9 col 8 to line 9 col 15. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Var y : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
y + zzIn cil_expr_2_scalar Var y : int 
yIn cil_expr_2_scalar Var x : int 
x Warning : Not a basic instruction : IfIn file : main.c, from line 10 col 10 to line 10 col 23. /n 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 15 col 6 to line 15 col 12. /n 
[ Extended cfg Adding : Ecfg node id  : 55, Framac sid 8 ] 
 Scheduling another vertex for execution 
[ Extended cfg Adding : Ecfg node id  : 58, Framac sid 9 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar PlusA(Var y : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
y + zzIn cil_expr_2_scalar Var y : int 
yIn cil_expr_2_scalar Var x : int 
x Warning : Not a basic instruction : IfIn file : main.c, from line 10 col 10 to line 10 col 23. /n 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 15 col 6 to line 15 col 12. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar Var __retres : int 
__retres[ Extended cfg Adding : Ecfg node id  : 60, Framac sid 10 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar PlusA(Var y : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
y + zzIn cil_expr_2_scalar Var y : int 
yIn cil_expr_2_scalar Var x : int 
x Warning : Not a basic instruction : IfIn file : main.c, from line 10 col 10 to line 10 col 23. /n 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 15 col 6 to line 15 col 12. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Var y : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
y + zzIn cil_expr_2_scalar Var y : int 
yIn cil_expr_2_scalar Var x : int 
x Warning : Not a basic instruction : IfIn file : main.c, from line 10 col 10 to line 10 col 23. /n 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 15 col 6 to line 15 col 12. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar Var __retres : int 
__retres[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 

3 * y + zIn cil_expr_2_scalar Var z : int 
zIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)
x + yIn cil_expr_2_scalar Var y : int 
yIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 

n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 

n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[ Extended cfg Adding : Ecfg node id  : 56, Framac sid 11 ] 
 Scheduling another vertex for execution 
[ Extended cfg Adding : Ecfg node id  : 57, Framac sid 12 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 

3 * y + zIn cil_expr_2_scalar Var z : int 
zIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)
x + yIn cil_expr_2_scalar Var y : int 
yIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 

n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 

n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 

((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 11In cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 
(3 * m + 5 * (n - 1)) + 7 * (
                                                                    p - 2)In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 

7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
5 * (n - 1)In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
((3 * m + 
                                                                  5 * (
                                                                  n - 1)) + 
                                                                 7 * (
                                                                 p - 2)) + 11In cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
3 * y + zzIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)
9 * (x + y) + 12In cil_expr_2_scalar 12 
12In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 

9 * (x + y)In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 

m + In cil_expr_2_scalar Mult(5,Var x : int) : int 
5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 

m + In cil_expr_2_scalar Mult(5,Var x : int) : int 
5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
3 * y + zzIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)9 * (x + y) + 12In cil_expr_2_scalar 12 
12In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 

9 * (x + y)In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 

x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * x
5 * xIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * x
5 * xIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 
(3 * m + 5 * (n - 1)) + 
                                                     7 * (p - 2)In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)
p - 2In cil_expr_2_scalar 2 
2In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
5 * (n - 1)In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
((3 * m + 5 * (n - 1)) + 
                                                      7 * (p - 2)) + 11In cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
3 * y + zzIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)
9 * (x + y) + 12In cil_expr_2_scalar 12 
12In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 

9 * (x + y)In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 

m + In cil_expr_2_scalar Mult(5,Var x : int) : int 
5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 

m + In cil_expr_2_scalar Mult(5,Var x : int) : int 
5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
3 * y + zzIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)9 * (x + y) + 12In cil_expr_2_scalar 12 
12In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 

9 * (x + y)In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 

x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * x
5 * xIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * x
5 * xIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 
(3 * m + 5 * (n - 1)) + 
                                                     7 * (p - 2)In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)
p - 2In cil_expr_2_scalar 2 
2In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
5 * (n - 1)In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
((3 * m + 5 * (n - 1)) + 
                                                      7 * (p - 2)) + 11In cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
3 * y + zzIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)
9 * (x + y) + 12In cil_expr_2_scalar 12 
12In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 

9 * (x + y)In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 

m + In cil_expr_2_scalar Mult(5,Var x : int) : int 
5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 

m + In cil_expr_2_scalar Mult(5,Var x : int) : int 
5 * xIn cil_expr_2_scalar Var x : int 
5 * xxIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar PlusA(Mult(3,Var y : int) : int,Var z : int) : int 
In cil_expr_2_scalar Var z : int 
3 * y + zzIn cil_expr_2_scalar Mult(3,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
3 * yyIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(2,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
2 * yyIn cil_expr_2_scalar 2 
2[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)9 * (x + y) + 12In cil_expr_2_scalar 12 
12In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 

9 * (x + y)In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
In cil_expr_2_scalar Var y : int 
x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar PlusA(Var m : int,PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int) : int 
In cil_expr_2_scalar PlusA(Mult(9,PlusA(Var x : int,Var y : int) : int) : int,12) : int 
m + (9 * (x + y) + 12)In cil_expr_2_scalar 12 
9 * (x + y) + 1212In cil_expr_2_scalar Mult(9,PlusA(Var x : int,Var y : int) : int) : int 
In cil_expr_2_scalar PlusA(Var x : int,Var y : int) : int 
9 * (x + y)In cil_expr_2_scalar Var y : int 

x + yyIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 9 
9In cil_expr_2_scalar Var m : int 
m[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * x
5 * xIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar MinusA(Var n : int,PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int) : int 
In cil_expr_2_scalar PlusA(PlusA(Var m : int,Mult(5,Var x : int) : int) : int,Mult(11,Var y : int) : int) : int 
n - ((m + 5 * x) + 11 * y)In cil_expr_2_scalar Mult(11,Var y : int) : int 
(m + 5 * x) + 11 * yIn cil_expr_2_scalar Var y : int 
11 * yyIn cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(Var m : int,Mult(5,Var x : int) : int) : int 
In cil_expr_2_scalar Mult(5,Var x : int) : int 
m + 5 * x
5 * xIn cil_expr_2_scalar Var x : int 
xIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Var m : int 
mIn cil_expr_2_scalar Var n : int 
n[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
In cil_expr_2_scalar 11 
((3 * m + 5 * (n - 1)) + 7 * (p - 2)) + 1111In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 
(3 * m + 5 * (n - 1)) + 
                                                     7 * (p - 2)In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)
p - 2In cil_expr_2_scalar 2 
2In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
5 * (n - 1)In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3In cil_expr_2_scalar PlusA(PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int,11) : int 
((3 * m + 5 * (n - 1)) + 
                                                      7 * (p - 2)) + 11In cil_expr_2_scalar 11 
11In cil_expr_2_scalar PlusA(PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int,Mult(7,MinusA(Var p : int,2) : int) : int) : int 

(3 * m + 5 * (n - 1)) + In cil_expr_2_scalar Mult(7,MinusA(Var p : int,2) : int) : int 
7 * (p - 2)In cil_expr_2_scalar MinusA(Var p : int,2) : int 
7 * (p - 2)In cil_expr_2_scalar 2 
p - 22In cil_expr_2_scalar Var p : int 
pIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(3,Var m : int) : int,Mult(5,MinusA(Var n : int,1) : int) : int) : int 
In cil_expr_2_scalar Mult(5,MinusA(Var n : int,1) : int) : int 
3 * m + 5 * (n - 1)
5 * (n - 1)In cil_expr_2_scalar MinusA(Var n : int,1) : int 
In cil_expr_2_scalar 1 
n - 11In cil_expr_2_scalar Var n : int 
nIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar Mult(3,Var m : int) : int 
In cil_expr_2_scalar Var m : int 
3 * mmIn cil_expr_2_scalar 3 
3[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 8 col 2 to line 16 col 3. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
SLOCAL [ __retres:int ] = 
SLOCAL [ tmp_0:int ] = 
SLOCAL [ tmp:int ] = 
SLOCAL [ i:int ] = 
SLOCAL [ x:int ] = 
 
flatac_visitor: Index of global types :  
[get°entry_point_from_fundec ]  New absdom : $\Formula{\texttt{true}}{\Emp}$ 
[get°entry_point_from_fundec ]  Absdom after registering slocals : $\Formula{\texttt{true}}{\Emp}$ 
[get°entry_point_from_fundec ]  Absdom after registering sformals : $\Formula{\texttt{true}}{\Emp}$ 
[ Extended cfg Adding : Ecfg node id  : -2, Framac sid 0 ] 
 [FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar 0 
0In cil_expr_2_scalar 0 
0[ Extended cfg Adding : Ecfg node id  : 62, Framac sid 1 ] 
 Scheduling another vertex for execution 
 Warning : Not a basic instruction : Loop In file : main.c, from line 24 col 2 to line 25 col 52. /n 
[ Extended cfg Adding : Ecfg node id  : 63, Framac sid 2 ] 
 Scheduling another vertex for execution 
 Warning : Not a basic instruction : IfIn file : main.c, from line 24 col 14 to line 24 col 21. /n 
[ Extended cfg Adding : Ecfg node id  : 64, Framac sid 3 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar 100 
100In cil_expr_2_scalar Var i : int 
i Warning : Not a basic instruction : Unspecified sequence 
 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 24 col 2 to line 25 col 52. /n 
[ Extended cfg Adding : Ecfg node id  : 66, Framac sid 4 ] 
 Scheduling another vertex for execution 
[ Extended cfg Adding : Ecfg node id  : 65, Framac sid 5 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar 100 
100In cil_expr_2_scalar Var i : int 
i Warning : Not a basic instruction : Unspecified sequence 
 
 Warning : Not a basic instruction : Break toIn file : main.c, from line 24 col 2 to line 25 col 52. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] I have a call with some affectation to a variable
[FlataC] Dans Call de tmp=foo
In cil_expr_2_scalar Var i : int 
iIn cil_expr_2_scalar PlusA(Mult(2,Var i : int) : int,1) : int 
In cil_expr_2_scalar 1 
2 * i + 11In cil_expr_2_scalar Mult(2,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
2 * iiIn cil_expr_2_scalar 2 
2In cil_expr_2_scalar PlusA(Mult(3,Var i : int) : int,5) : int 
In cil_expr_2_scalar 5 
3 * i + 55In cil_expr_2_scalar Mult(3,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
3 * iiIn cil_expr_2_scalar 3 
3[next_on_ssl_instr] Integer type Var : tmp = Var foo : Function of return type : int : int 
[next_on_ssl_instr] argument list tmp'=foo(i,2*i+1,3*i+5) 
 [ Extended cfg Adding : Ecfg node id  : 67, Framac sid 6 ] 
 Scheduling another vertex for execution 
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar 0 
0In cil_expr_2_scalar 0 
0[ Extended cfg Adding : Ecfg node id  : 71, Framac sid 7 ] 
 Scheduling another vertex for execution 
[FlataC] Dans next_on_ssl_instr
[FlataC] I have a call with some affectation to a variable
[FlataC] Dans Call de tmp=foo
In cil_expr_2_scalar Var i : int 
iIn cil_expr_2_scalar PlusA(Mult(2,Var i : int) : int,1) : int 

2 * i + 1In cil_expr_2_scalar 1 
1In cil_expr_2_scalar Mult(2,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
2 * iiIn cil_expr_2_scalar 2 
2In cil_expr_2_scalar PlusA(Mult(3,Var i : int) : int,5) : int 
In cil_expr_2_scalar 5 
3 * i + 55In cil_expr_2_scalar Mult(3,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
3 * iiIn cil_expr_2_scalar 3 
3[next_on_ssl_instr] Integer type Var : tmp = Var foo : Function of return type : int : int 
[next_on_ssl_instr] argument list tmp'=foo(i,2*i+1,3*i+5) 
 [FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar 0 
0In cil_expr_2_scalar 0 
0[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] I have a call with some affectation to a variable
[FlataC] Dans Call de tmp_0=bar
In cil_expr_2_scalar PlusA(Mult(5,Var i : int) : int,1) : int 
In cil_expr_2_scalar 1 
5 * i + 11In cil_expr_2_scalar Mult(5,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
5 * iiIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar PlusA(Mult(7,Var i : int) : int,2) : int 
In cil_expr_2_scalar 2 
7 * i + 22In cil_expr_2_scalar Mult(7,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
7 * iiIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(9,Var i : int) : int,3) : int 

9 * i + 3In cil_expr_2_scalar 3 
3In cil_expr_2_scalar Mult(9,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
9 * iiIn cil_expr_2_scalar 9 
9[next_on_ssl_instr] Integer type Var : tmp_0 = Var bar : Function of return type : int : int 
[next_on_ssl_instr] argument list tmp_0'=bar(5*i+1,7*i+2,9*i+3) 
 [ Extended cfg Adding : Ecfg node id  : 68, Framac sid 8 ] 
 Scheduling another vertex for execution 
In cil_expr_2_scalar Var __retres : int 
__retres[ Extended cfg Adding : Ecfg node id  : 72, Framac sid 9 ] 
 Scheduling another vertex for execution 
[FlataC] Dans next_on_ssl_instr
[FlataC] I have a call with some affectation to a variable
[FlataC] Dans Call de tmp_0=bar
In cil_expr_2_scalar PlusA(Mult(5,Var i : int) : int,1) : int 
In cil_expr_2_scalar 1 
5 * i + 11In cil_expr_2_scalar Mult(5,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
5 * iiIn cil_expr_2_scalar 5 
5In cil_expr_2_scalar PlusA(Mult(7,Var i : int) : int,2) : int 
In cil_expr_2_scalar 2 
7 * i + 22In cil_expr_2_scalar Mult(7,Var i : int) : int 
In cil_expr_2_scalar Var i : int 
7 * iiIn cil_expr_2_scalar 7 
7In cil_expr_2_scalar PlusA(Mult(9,Var i : int) : int,3) : int 
In cil_expr_2_scalar 3 
9 * i + 33In cil_expr_2_scalar Mult(9,Var i : int) : int 
In cil_expr_2_scalar Var i : int 

9 * iiIn cil_expr_2_scalar 9 
9[next_on_ssl_instr] Integer type Var : tmp_0 = Var bar : Function of return type : int : int 
[next_on_ssl_instr] argument list tmp_0'=bar(5*i+1,7*i+2,9*i+3) 
 [FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
In cil_expr_2_scalar Var __retres : int 
__retres[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var tmp : int,Var tmp_0 : int) : int 
In cil_expr_2_scalar Var tmp_0 : int 
tmp + tmp_0tmp_0In cil_expr_2_scalar Var tmp : int 
tmpIn cil_expr_2_scalar PlusA(Var tmp : int,Var tmp_0 : int) : int 
In cil_expr_2_scalar Var tmp_0 : int 
tmp + tmp_0tmp_0In cil_expr_2_scalar Var tmp : int 
tmp[ Extended cfg Adding : Ecfg node id  : 69, Framac sid 10 ] 
 Scheduling another vertex for execution 
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var tmp : int,Var tmp_0 : int) : int 
In cil_expr_2_scalar Var tmp_0 : int 
tmp + tmp_0tmp_0In cil_expr_2_scalar Var tmp : int 
tmpIn cil_expr_2_scalar PlusA(Var tmp : int,Var tmp_0 : int) : int 

tmp + tmp_0In cil_expr_2_scalar Var tmp_0 : int 
tmp_0In cil_expr_2_scalar Var tmp : int 
tmp[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var i : int,1) : int 
In cil_expr_2_scalar 1 
i + 11In cil_expr_2_scalar Var i : int 
iIn cil_expr_2_scalar PlusA(Var i : int,1) : int 
In cil_expr_2_scalar 1 
i + 11In cil_expr_2_scalar Var i : int 
i[ Extended cfg Adding : Ecfg node id  : 70, Framac sid 11 ] 
 Scheduling another vertex for execution 
[FlataC] Dans next_on_ssl_instr
[FlataC] Trying to handle an affectation
[FlataC] The left value is a variablex
[FlataC] Entering affect_int_val_upon_sslv
In cil_expr_2_scalar PlusA(Var i : int,1) : int 
In cil_expr_2_scalar 1 
i + 11In cil_expr_2_scalar Var i : int 
iIn cil_expr_2_scalar PlusA(Var i : int,1) : int 
In cil_expr_2_scalar 1 
i + 11In cil_expr_2_scalar Var i : int 
i[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 24 col 2 to line 25 col 52. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
 Warning : Not a basic instruction : Loop In file : main.c, from line 24 col 2 to line 25 col 52. /n 
[FlataC] I reached does_entail
 
 [ accept_new_abstraction ] 
******************** 
 Left  formula : 
 Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
 Right formula  
Exists [ ]Pure{Eq []Aff []Ptnil []} || Space{Emp}
*********************** 
 
  
 [ accept_entailenebt ] FALSE, rigth formula is entailed by a more precise one
[FlataC] nts main; 
         main {
         in ()
         
         __retres,tmp_0,tmp,i,x : int
         initial s0;
         final s9;
          
          s0 -> s1 { i'=0 } 
          
          s1 -> s2 {  } 
          
          s2 -> s3 {  } 
          
          s3 -> s4 { i < 100 } 
          
          s3 -> s5 { i >= 100 } 
          
          s4 -> s6 { tmp'=foo(i,2*i+1,3*i+5) } 
          
          s5 -> s7 { __retres'=0 } 
          
          s6 -> s8 { tmp_0'=bar(5*i+1,7*i+2,9*i+3) } 
          
          s7 -> s9 { ret_val_'=__retres } 
          
          s8 -> s10 { x'=tmp+tmp_0 } 
          
          s10 -> s11 { i'=i+1 } 
          
          s11 -> s2 {  } 
         
         }
         nts foo; 
         foo {
         in (z,y,x : int)
         
         __retres : int
         initial s0;
         final s2;
          
          s0 -> s1 { __retres'=5*((x+12)*(3*y+7*z+1)) } 
          
          s1 -> s2 { ret_val_'=__retres } 
         
         }
         nts bar; 
         bar {
         in (z,y,x : int)
         
         __retres,p,n,m : int
         initial s0;
         final s10;
          
          s0 -> s1 { p'=0 } 
          
          s1 -> s2 {  } 
          
          s2 -> s3 {  } 
          
          s3 -> s4 { x > 0 } 
          
          s3 -> s5 { x <=  0 } 
          
          s4 -> s6 {  } 
          
          s5 -> s7 { __retres'=3*m+5*(n-1)+7*(p-2)+11 } 
          
          s6 -> s8 { x < y+z } 
          
          s6 -> s9 { x >= y+z } 
          
          s7 -> s10 { ret_val_'=__retres } 
          
          s8 -> s11 { 2*y > 3*y+z and m'=m+9*(x+y)+12 } 
          
          s8 -> s12 { 2*y <=  3*y+z and n'=n-(m+5*x+11*y) } 
          
          s9 -> s7 { __retres'=3*m+5*(n-1)+7*(p-2)+11 } 
          
          s11 -> s2 {  } 
          
          s12 -> s2 {  } 
         
         }
          
          States of : main 
         Key_id 0, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 1, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 2, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 3, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 4, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 5, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 6, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 7, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 8, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 9, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 10, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 11, absval : $\Formula{\texttt{true}}{\Emp}$ 
         
          
          States of : foo 
         Key_id 0, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 1, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 2, absval : $\Formula{\texttt{true}}{\Emp}$ 
         
          
          States of : bar 
         Key_id 0, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 1, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 2, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 3, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 4, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 5, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 6, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 7, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 8, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 9, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 10, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 11, absval : $\Formula{\texttt{true}}{\Emp}$ 
         Key_id 12, absval : $\Formula{\texttt{true}}{\Emp}$
Starting
Visiting foo
Visiting bar
Visiting main
 [Debug visitor] !!! Skipping instruction !!!In statement :79, skipping to statement 80,  located at  In file : , from line 0 col -1 to line 0 col -1. /n  
 [Debug visitor] !!! Skipping instruction !!!In statement :88, skipping to statement 89,  located at  In file : , from line 0 col -1 to line 0 col -1. /n  
 [Debug visitor] !!! Skipping instruction !!!In statement :94, skipping to statement 95,  located at  In file : , from line 0 col -1 to line 0 col -1. /n  
 [Debug visitor] !!! Skipping instruction !!!In statement :102, skipping to statement 103,  located at  In file : , from line 0 col -1 to line 0 col -1. /n  
 [Debug visitor] !!! Unspecified sequence !!! 
f2ca printed the cautomaton ton the file 
 