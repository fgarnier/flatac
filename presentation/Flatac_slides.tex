%\include{commands}

\documentclass[compress]{beamer}
%\documentclass{beamer}

\usepackage{beamerthemeJuanLesPins}
\usepackage{amsfonts,amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{listings}

\usepackage[latin1]{inputenc}
%\usepackage{dcpic,pictex} %for commutative diagrams

\newcommand\xor{\oplus}
\newcommand{\emath}[1]{\ensuremath{#1}}
  \newcommand\tred[1]{\textcolor{red}{#1}}
  \newcommand\tblue[1]{\textcolor{blue}{#1}}
\newcommand\tgreen[1]{\textcolor{green}{#1}}
%\newcommand\tred[1]{\textcolor{red}{#1}}
\usepackage[small,nhug,heads=vee]{diagrams}
\diagramstyle[labelstyle=\scriptstyle]

\input{macro_filip}

%%%%%%%%%%%%%%%%%%%%%%  SSL RELATED STUFFS %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\bi}[1]{{}^\omega\!{#1}^\omega}
\newcommand{\rbr}{{\bf ]\!]}}
\newcommand{\lbr}{{\bf [\![}}


\newcommand{\sem}[1]{\lbr #1 \rbr}

\newcommand{\arrow}[2]{\xrightarrow[{\scriptstyle #2}]{{\scriptstyle #1}}}

\newcommand{\defeq}[0]{:=}
\newcommand{\syntaxeq}[0]{::=}

\newcommand{\Dom}[1]{\mathcal{D}om(#1)}

\newcommand{\rrule}[2]{\lstinline!#1!  \to \lstinline!#2!}
\newcommand\Addr{\mathcal{A}ddr} %The set of heap addresses
\newcommand\LVar{\mathcal{L}Var} %The set of location variables
\newcommand\PVar{\mathcal{P}Var} %The set of pointer variables.

\newcommand{\Pp}[1]{PP(#1)} %% The set of the atomic propositions that appear inside a formula.
\newcommand{\Sp}[1]{SP(#1)} %% The set of spacial propositions that appear insde a formula.


%Size of a formula.
\newcommand{\sizef}[1]{|{#1}|}
%subformula
\newcommand{\subf}[0]{\triangleright}

\newcommand{\gton}[1]{>_{#1}}
\newcommand{\gtlvar}[0]{\gton{\LVar}}
\newcommand{\gtptrvar}[0]{\gton{\PVar}}

\newcommand{\Locvar}[1]{Locvar(#1)} %The set of location variables appearing
	%in a formula
\newcommand{\Ptrvar}[1]{Ptrvar(#1)} %same as abovem but for Ptr variables.

\newcommand{\NULL}[0]{\mbox{\texttt{NULL}}}

\newcommand{\Alloc}[1]{alloc(#1)}
\newcommand{\Emp}{\lstinline{Emp}}

\newcommand{\Unsep}[0]{\ast}
\newcommand{\Sep}[2]{#1 \Unsep #2}
\newcommand{\Sepf}[2]{ #1 \star #2}

\newcommand{\EqLoc}[2]{ (#1 = #2) }
\newcommand{\Andpure}[2]{ #1 \wedge #2}
\newcommand{\Pointsto}[2]{ #1 \mapsto #2}
\newcommand{\nil}[0]{\lstinline!nil!}
\newcommand{\Pointstonil}[1]{ #1 \mapsto \mbox{\nil}}
\newcommand{\Formula}[2]{ #1  \updownarrow #2}
\newcommand{\Exists}[2]{ \exists #1. #2}

\newcommand{\Substin}[3]{#1\lbrack #2 \gets #3 \rbrack}
\newcommand{\NForm}[1]{\mathcal{NF}(#1)}

\newcommand{\Ran}[1]{\mathcal{R}an(#1)}

\newcommand{\Vars}[1]{\mathcal{V}ars(#1)}
\newcommand{\FVars}[1]{\mathcal{F}Vars(#1)}


\newcommand{\Equa}[1]{\mathcal{E}q(#1)}
\newcommand{\Aff}[1]{\mathcal{A}ff{#1}}
\newcommand{\Nullptr}[1]{\mathcal{N}ullptr{#1}}


\newcommand{\Subst}[3]{#3\lbrack #1\leftarrow #2 \rbrack}
\newcommand{\fundec}[5]{\begin{array}{llll} {#1}:&{#2} &\mapsto & {#3} \\ &{#4} & \mapsto& #5  \end{array}}


% add/replaces A.P. #2 in formula #1.
\newcommand{\Addrep}[2]{#1 \lbrack #2 \rbrack}


%%%%%%%%%%% Compute new name for existential variables %%%%%%%%

\newcommand{\renfresh}[2]{Renfresh(#1,#2)}



%%%%%%%%%% Order Relation %%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\LocOrderIneq}[0]{\sqsubset_{I}}
\newcommand{\LocOrderIeq}[0]{\sqsubseteq_{I}}
\newcommand{\PtrOrderIneq}[0]{\sqsubset_{S}}
\newcommand{\PtrOrderIeq}[0]{\sqsubseteq_{S}}
\newcommand{\ModOrderIeq}[0]{\sqsubseteq_{I,S}}
\newcommand{\ModOrderIneq}[0]{\sqsubset_{I,S}}


\newcommand{\true}{true}
\newcommand{\false}{false}
\newcommand{\dk}{dk}
%% #1 var name, #2 base, size, #4 offset
\newcommand{\ptrexp}[3]{\left ( \begin{array}{l} 
\ptrbase{#1}=#2 \\ 
\ptroffset{#1}=#3
\end{array} \right )}


\newcommand{\base}[2]{base_{#1}(#2)}
\newcommand{\samebase}[3]{Same\_base_{#1}({#2},{#3})}

\newcommand{\lbase}[1]{#1_{base}}
\newcommand{\lsize}[1]{#1_{size}}

\newcommand{\locvar}[3]{
\left ( \begin{array}{l}
\lbase{#1}=#2 \\
\lsize{#1}=#3
\end{array} \right )
}
%%%%%%%%%%%%% Hoar triples and sematic transformations %%%%%%%%%%%%%%%%%

%     instr  
% {P} -----> {Q}
%     effect
\newcommand{\transmodel}[4]{\lbrace #1 \rbrace \arrow{#2}{#3} \lbrace #4 \rbrace }

\newcommand{\Pre}[0]{\lbrace P \rbrace}
\newcommand{\Post}[0]{\lbrace Q \rbrace}

%%%%%%%%%%%% Footprint related stuff %%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\newcommand{\ptrbase}[1]{{#1}_{base}}
\newcommand{\ptrsize}[1]{{#1}_{size}}
\newcommand{\ptroffset}[1]{{#1}_{off}}
\newcommand{\gmallocid}[0]{mid}


\newcommand{\interpretZ}[1]{\sem{#1}_{\mathbb{Z}}}
\newcommand{\interpretI}[1]{\sem{#1}_{I}}
\newcommand{\interpretP}[1]{\sem{#1}_{P}}
\newcommand{\interpretC}[1]{\sem{#1}_{C}}

\newcommand{\Eval}[1]{Eval(#1)}

%%%%%%%%%%%%%%%%%%% Validity interpretation compters 
\newcommand{\ival}[1]{{#1}_{\mbox{valid}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inline text typology and other short notation definitions        %

\newcommand{\nth}[1]{$#1^{\mbox{th}}$}
\newcommand{\rd}[1]{$#1^{\mbox{rd}}$}


\newcommand{\syneq}[0]{::=} %Syntatic definition
\newcommand{\seq}[0]{\equiv} %Syntactic equality/equivalence

%%%%%%%%% Arithmetic operations
\newcommand{\intval}[2]{\left ( \begin{array}{l} #1 \\ #2 \end{array} \right )}

\newcommand{\valid}[1]{{#1}_{\mbox{\lstinline!valid!}}}
\newcommand{\intptr}[2]{\left ( \begin{array}{l} {#1} \\ {#2} 

\end{array} \right )}

\newcommand{\segfault}[0]{\mbox{\lstinline!segfault!}}

\newcommand{\andmath}[0]{\mbox{and}}
\newcommand{\congmod}[3]{#1 \equiv #2 \lbrack #3 \rbrack}
\newcommand{\notcongmod}[3]{#1 \not\equiv #2 \lbrack #3 \rbrack}
\newcommand{\isvalid}[2]{Valid_{#1}(#2)}
\newcommand{\DK}[2]{DK_{#1}(#2)}
%\newcommand{\interpa}[2]{Tr_{#1}(#2)}
\newcommand{\interpa}[2]{\sem{#2}_{#1}}

\newcommand{\interpacomp}[2]{Comp_{#1}(#2)}
\newcommand{\FRAMAC}{FRAMA-C}
\newcommand{\sizeof}[1]{\mbox{\lstinline!sizeof!}(#1)}

%% Counter associated to an interger variable.
\newcommand{\icnt}[1]{#1_{\mbox{cnt}}}

%% Access to memory @ pointer address P :
\newcommand{\accs}[1]{\mbox{\lstinline!access!}(#1)}



%%%%%%%%%%%%%%%%%% SSL RELATED STUFFS END BLOCK %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
  
  

%  \newcommand\bo[1]{\mathcal{#1}}
%  \newcommand\mA{\bo{A}}
%  \newcommand\terminemachin{+a.s. }
%  \newcommand\truc\terminemachin
%  \newtheorem{proposition}{Proposition}
%  \newtheorem{condition}{Condition}
%  \newtheorem{exemple}{Exemple}
%  \newtheorem{theoreme}{Theorème}
%
%  \newtheorem{notation}{Notation}
%  \newcommand\notat[2]{\begin{condition}[#1] #2 \end{condition}}
%
%  \newcommand\cond[2]{\begin{condition}[#1] #2 \end{condition}}
%  \newtheorem{remarque}{Remarque}
  \usepackage{latexsym}
  \usepackage{graphicx}

%\input{../macros}

  \title{The Flatac Frama-c front-end}
 % \part{Main}


  \author{Radu Iosif, Florent Garnier}

\begin{document}
\frame{\titlepage 
}

\date{Febuary 2012}
%\part{Main}


\begin{frame}
\frametitle{Outline}
 \tableofcontents[pausesections]
\end{frame}



\section{Introduction }


\subsection{Motivations}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-24.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-25.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-26.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-27.pdf}
\end{center}
}


\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-28.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-29.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-30.pdf}
\end{center}
}


\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-31.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-32.pdf}
\end{center}
}


\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-33.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-34.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-35.pdf}
\end{center}
}

\frame{
\begin{center}
\includegraphics[angle=270,width=0.7\textwidth]{torino-36.pdf}
\end{center}
}

\subsection{What is flatac}
\frame{
\frametitle{What is flatac ?}
\begin{itemize}
\item Part of a toolchain that aims at proving that C programs don't generate memory faults and don't violates assertions.
\item A front end that generates NTS based models of C programs.
\item Coded as a Frama-C plugin. 
\end{itemize}
}

\subsection{Tracking memory faults}
\frame{
\frametitle{Typical memory faults :}

\begin{itemize}
\item Memory access outside and allocated memory zone of the heap 
\item Access to an array outside of its bounds
\item Memory access using a non aligned address
\item Double free
\item Freeing an allocated segment using an pointer that does not points at the begining of the segment.
\item Memory leaks
\end{itemize}
}

\frame{
\frametitle{Two subkinds of properties :}
\begin{itemize}
\item Properties concerning the memory shape (Simple Separation Logic):
	\begin{itemize}
	\item Relation between pointer variables (Stack) and location variables (heaps).
	\item Memory allocation.
	\item Allocated Segment separation.

	\end{itemize}
\item Arithmetic properties :
	\begin{itemize}
	\item Memory segment access within its bounds. 
	\item Memory address alignment (Congruence).
	\end{itemize}
\end{itemize}
}

\frame{
\frametitle{Tracked property}
\tgreen{This front end aims at proving that C programs :}
\begin{itemize}
\item Have no execution run that lead to memory fault.
\item Have no exectution that violates some assertion expressed
using arithmetic constraints.
\end{itemize}
\tgreen{Flatac plugin: Front end of NTS error state reachability analysis }
\begin{itemize}
\item Extracts models of C Programs using Abstract Interpretation Techniques. 
\item Adds \tred{Numerical Transitions Systems} informations on the
model for \tred{a posteri Verification Phase}.  

\end{itemize}
}






\frame{
\frametitle{How to do that ?}
\begin{enumerate}
\item Extracting an extended cfg from Frama-c cfg $($Cil statements $\times$SSL memory abstractions$)^2$
\item Labelling the Ecfg transitions with Numerical Transition System expression --Guards, counter affectation and Function Calls.
\item If a SSL Abs value of a state is $\bot$, define this state as
an error state.
\item Export the labelled Ecfg into Nts Format.
\item Ask an analysis tool --Flata, Eldarica, to check whether 
some error state is reachable from the entry point (main function).

\end{enumerate}

}



\subsection{Flata-c a link in a toolchain}
\frame{
\frametitle{Flatac in the tool-chain:}
\begin{center}
\resizebox{9.5cm}{7cm}{\input{toolchain.pstex_t}}
\end{center}


}


\section{Abstract reprentation of the memory}
\subsection{The SSL logic}
\frame{
\frametitle{Abstract interpretation preliminary part}
 Simple Separation Logic formulae : Abstract domain.

\begin{block}{Syntax of SSL}
$$
\begin{array}{lclr}
\phi & := & \Formula{\pi}{\sigma} \gspace | \gspace \Exists{l}{\phi} & \mbox{Formulae} \\
\pi & := & \Pointsto{x}{l} \gspace | \gspace \Pointstonil{x} \gspace | \gspace \EqLoc{l_1}{l_2} \gspace | \gspace \Andpure{\pi_1}{\pi_2} & {\mbox{Pure part}} \\
\sigma &:=& \Emp  \gspace | \gspace \Alloc{l} \gspace | \gspace \Sep{\sigma_1}{\sigma_2}\ \gspace | \gspace \bot & \mbox{Spatial part}
\end{array}
$$
\end{block}

}



\frame{
\frametitle{Good properties of SSL}

\begin{block}{Properties}
The problem that follows are decidable :
\begin{itemize}
\item Satisfiability (Valid configuration)
\item Entailment, Equivalence.
\item SSL formula with $\vdash$ is a complete latice.
\item Memory leaks
\end{itemize}
\end{block}

Those problems are solved using rewriting techniques.
}

\frame{
\frametitle{Example of SSL formulae}
\begin{itemize}
\item $\Formula{ \Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Emp}$
\item $\Formula{\Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Alloc{l_1}}$
\item $\Formula{ \Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Sep{\Alloc{l_1}}{\Alloc{l}}}$
\item $\Formula{ \Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Sep{\Alloc{l_1}}{\Alloc{l}}}$
\item $\Formula{ \Andpure{x=y}{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}}{\Sep{\Alloc{l_1}}{\Alloc{l}}}$ (Unsat)
\item $\Formula{ \Andpure{x=y}{\Andpure{\Pointsto{x}{l_1}}{\Pointstonil{y}}}}{\Alloc{l_1}}$ (Unsat)
\item $\Formula{ true }{\Alloc{l}}$ (Leak)
\end{itemize}
}


\subsection{Memory model}
\frame{
\frametitle{Flata-c Memory model}
A memory model that associates counters to SSL
variables :

\begin{block}{Additional quantitative informations}
$$
\begin{array}{lcr}
\mbox{SSL Variable} & \mbox{NTS counter} & \\
x\in PVar & \mbox{\texttt{x\_offset}} & \mbox{offset} \\
l\in LVar & \mbox{\texttt{l\_size}} & \mbox{segment size}
\end{array}
$$
In order to :
\begin{itemize}
\item Associate to segment their size.
\item Associate to pointer their offset.
\item To express guards on memory access.
\end{itemize}
\end{block}
}

\frame{
\frametitle{Example}
$$
\begin{array}{lll}
\mbox{C "statement"} & \mbox{SSL formula}& \texttt{NTS transition} \\
\mbox{\texttt{int *x;}} &\Formula{\exists l \Pointsto{x}{l}}{\Emp}&\texttt{offset\_x'=0}\\
\mbox{\texttt{x=malloc(10);}} &\Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}&\texttt{size\_l=10}\\
\mbox{\texttt{x++;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=sizeof(int)} \\
\mbox{\texttt{int y =*x;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'} < \mbox{size\_l} \\
&\Formula{\exists . l \Pointsto{x}{l}}{\Alloc{l}}& \mbox{havoc(y)}
\end{array}
$$

}

\frame{
\frametitle{Example}
$$
\begin{array}{lll}
\mbox{C "statement"} & \mbox{SSL formula}& \texttt{NTS transition} \\
\mbox{\texttt{int *x;}} &\Formula{\exists l \Pointsto{x}{l}}{\Emp}&\texttt{offset\_x'=0}\\
\mbox{\texttt{x=malloc(10);}} &\Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}&\texttt{size\_l=10}\\
\mbox{\texttt{x++;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=sizeof(int)} \\
\mbox{\texttt{int y =*x;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'}<\mbox{size\_l} \\
&\Formula{\exists . l \Pointsto{x}{l}}{\Alloc{l}}& \mbox{havoc(y)}\\
\mbox{\texttt{x+=10;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=10*sizeof(int)} \\
\end{array}
$$
}



\frame{
\frametitle{Example}
$$
\begin{array}{lll}
\mbox{C "statement"} & \mbox{SSL formula}& \texttt{NTS transition} \\
\mbox{\texttt{int *x;}} &\Formula{\exists l \Pointsto{x}{l}}{\Emp}&\texttt{offset\_x'=0}\\
\mbox{\texttt{x=malloc(10);}} &\Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}&\texttt{size\_l=10}\\
\mbox{\texttt{x++;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=sizeof(int)} \\
\mbox{\texttt{int y =*x;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'}<\mbox{size\_l} \\
&\Formula{\exists . l \Pointsto{x}{l}}{\Alloc{l}}& \mbox{havoc(y)}\\
\mbox{\texttt{x+=10;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=10*sizeof(int)} \\
\mbox{\texttt{*x=42;}} & \bot & \tred{\texttt{offset\_x}\geq\mbox{size\_l}} \\
\end{array}
$$

\tred{Access to \texttt{*x} is out of bounds of allocated segment at \texttt{l}.}
}


\section{Model extraction}
\subsection{Cil representation of C programs}
\frame{
\frametitle{Cil representation of C programs}

Cil provides and AST and CFG info from C files.

\begin{block}{Most relevant information}
For each function of the AST :
\begin{itemize}
\item Expressions.
\item Locals and formal variables.
\item Statements of the Control flow graph.

\end{itemize}
\end{block}

}



\frame{
\frametitle{From cil statments to NTS}
\begin{center}
\resizebox{8cm}{!}{\input{Cilstatements.pstex_t}}
\end{center}
}


\subsection{Extraction steps}

\frame{
\frametitle{Step 1 : Compile expression + Valid mem conditions}
\begin{center}
\resizebox{8cm}{!}{\input{compilestep1.pstex_t}}
\end{center}
}


\frame{
\frametitle{Step 2 : Updating absdomain evaluation}
\begin{center}
\resizebox{8cm}{!}{\input{compilestep2.pstex_t}}
\end{center}
}

\frame{
\frametitle{Step 3 : Recurse on all abstract successors}
\begin{center}
\resizebox{8cm}{!}{\input{compilestep3.pstex_t}}
\end{center}
}




\frame{
\frametitle{Nts guards for valid memory access}

Let \texttt{x} a $PVar$ such that \texttt{x:}$\tau$\texttt{*}
Let $\texttt{valid\_mem}:\texttt{Cil\_types.expr}\times SSL \mapsto NtsGuards$

\begin{block}{Memory access guards Cil for atomic expressions}
\begin{tabular}{lcl}
Cil expressions&Memory abstraction & Nts Guard \\ 
\texttt{*x} &$\Formula{\Pointsto{x}{l}}{\Alloc{l}}$ & \texttt{true}\\
\texttt{*x} &$\Formula{\Pointsto{x}{l}}{\Emp}$& \texttt{false}\\ 
\texttt{*(x+i)} & $\Formula{\Pointsto{x}{l}}{\Alloc{l}}$& $0\leq i\times$\texttt{sizeof(}$\tau$\texttt{)}$<$\texttt{l\_size}\\
\texttt{tab[i]}&$\Formula{true}{\Emp}$& $0\leq i <$ \texttt{tab\_size}\\

\end{tabular}
\end{block}
}




\frame{
\frametitle{Nts guards for valid memory access}
\begin{block}{Cil expression type definition (Non exhaustive)}
\begin{tabular}{l}
\texttt{UnOp(UOp,expr)} \\
\texttt{BinOp(BOp,expg,expd)}\\
\texttt{UOP}=\texttt{UnMin| BNot | Neg}$\ldots$ \\
\texttt{BOP}=\texttt{BAnd|BOr}$\ldots$\\
\phantom{UOP}\texttt{Plus|Minus|Prod|Div}$\ldots$\\
\phantom{BOP}\texttt{PlusPI|MinusPI|MinusPP}$\ldots$\\
\end{tabular}
\end{block}

\begin{block}{\texttt{valid\_mem} of Cil expression}
\begin{tabular}{ll}
Cil expr & \texttt{valid\_mem} \\
\texttt{UnOp(UOp,expr)} & \texttt{valid\_mem(expr)}\\
\texttt{BinOp(BOp,expg,expd)} & \texttt{valid\_mem(expg)}$\wedge$\texttt{valid\_mem(expg)} \\
\end{tabular}
\end{block}
}







\frame{
\frametitle{Compiling expressions}


\begin{block}{From pointer arithmetics to Nts expressions}
$$
\begin{array}{|lll|}
\hline
\base{\phi}{x}&:=& l \mbox{ if }  \Pointsto{x}{l} \in \Pp{\phi} \\
\base{\phi}{\NULL} &:=& \nil \gspace \forall \phi \\
\base{\phi}{P+I} &:=& \base{\phi}{P} \\

%\end{array}
%$$


%}

%\frame{
%\frametitle{Compiling Integer expressions}

%$$
%\begin{array}{|lll|}
 \interpa{\phi}{n} & := & n \\
\interpa{\phi}{i} & := & \icnt{i} \\
\interpa{\phi}{\NULL} & := & 0 \\
\interpa{\phi}{x} &:=& \ptroffset{x} \\
\interpa{\phi}{x_1 - x_2} & :=&  \ptroffset{x_1}-\ptroffset{x_2} \\
\interpa{\phi}{P+I} & := & \interpa{\phi}{P}+\interpa{\phi}{I}\times \sizeof{\tau}, \mbox{ where } P:\tau *\\
\interpa{\phi}{P_1 - P_2} & := & ( \interpa{\phi}{P_1}-\interpa{\phi}{P_2}) / \sizeof{\tau}, \mbox{ where } P_1:\tau * \\
\interpa{\phi}{I_1+I_2} &:=& \interpa{\phi}{I_1} + \interpa{\phi}{I_2} \\
\interpa{\phi}{I_1 \times I_2} &:= &\interpa{\phi}{I_1} \times \interpa{\phi}{I_2} \\
\hline
\end{array}
$$
\end{block}
}


\frame{
\frametitle{Compiling booleans to Nts guards}

\begin{block}{}
$$
\begin{array}{lll}

\interpa{\phi}{P_1 == P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} == \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\
&&\\
\interpa{\phi}{P_1 != P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} != \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\
&&\\
\interpa{\phi}{P_1 \bowtie P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} \bowtie \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\ 
\end{array}
$$
\end{block}
}


\frame{
\frametitle{Control flow statements v.s. basic instructions}

\begin{block}{Control flow statement}
Those require a special handling, to deal with the
case where \texttt{expr} is invalid.
\begin{itemize}
\item \texttt{if(expr,blockif,blockelse)}
\item \texttt{switch(expr,case\_list)}
\end{itemize}
\end{block}
Basic statement are easier to model.
\begin{block}{Instruction statement}
\begin{itemize}
\item \texttt{lval=expr}
\item \texttt{lval=funcall(name,exp list)}
\end{itemize}
\end{block}
}

\frame{
\frametitle{Model extraction :}

Input : Cil AST and Control flow graph

Generated Model : Extended CFG,
  
$(S_i,S_f,S_{err},S,\to \in (S\times R \times S)) $

where :
\begin{itemize}
\item $S \in  ($Cil\_types.stmt$\times \ Abs)$,
\item $Abs =$ Set of SSL formula $\bigcup \bot$, 
\item $R$ is a set of possibly guarded NTS transitions. 
\end{itemize}
}


\frame{
\frametitle{Extraction : Basic statment}

\begin{block}{\texttt{Var(v)=expr}}
\begin{center}
\resizebox{8cm}{!}{\input{affectvar.pstex_t}}
\end{center}
%\begin{diagram}
% &&\Formula{\true}{\Emp}\\
%\Formula{\true}{\Emp}&\ruTo^{\texttt{valid\_mem(expr)}}&\\
%&\rdTo^{\not\texttt{valid\_mem(expr)}}&\\
%&&\bot
%\end{diagram}
\end{block}
}



\frame{
\frametitle{Extraction : Basic statment}

\begin{block}{\texttt{lval=expr}}
Considered lvals are array element and referenced mem
cells. 
\begin{center}
\resizebox{8cm}{!}{\input{affectlval.pstex_t}}
\end{center}
%\begin{diagram}
% &&\Formula{\true}{\Emp}\\
%\Formula{\true}{\Emp}&\ruTo^{\texttt{valid\_mem(expr)}}&\\
%&\rdTo^{\not\texttt{valid\_mem(expr)}}&\\
%&&\bot
%\end{diagram}
\end{block}
}


\frame{
\frametitle{Extraction : Basic statement}
\begin{block}{\texttt{lval=call(fun,arg1},...,\texttt{argn)}}
Call of \texttt{fun} where \texttt{\{P\} fun \{Q\}}.
\begin{center}
\resizebox{7cm}{!}{\input{funcall.pstex_t}}
\end{center}

\end{block}
}


\frame{
\frametitle{Extraction : Control Flow operation}
\begin{block}{\texttt{if(test, stmtif, stmtelse)}}
Expression \texttt{test} might perform some illegal operations.
\begin{center}
\resizebox{5cm}{!}{\input{ifthen.pstex_t}}
\end{center}
\end{block}
}

\frame{
\frametitle{Extraction : Extended Cfg building algorithm}
When computing a new realation $(s_{curr},\phi),R,(s_{next},\phi^{\prime})$ do
\begin{itemize}
\item If $\exists (sid,\psi)\in S$ s.t. $sid=s_{next}$ and $\psi\vdash\phi$
then $\to = \to \cup (s_{curr},\phi),R,(s_{next},\psi)$
\item Else 
  \begin{itemize}
  \item $\to = \to \cup (s_{curr},\phi),R,(s_{next},\phi^{\prime})$
  \item Recurse on abstract state $(s_{next},\phi^{\prime})$
  \end{itemize}
\end{itemize}

\begin{block}{Termination}
This algorith terminates as the $sid$ index is a fixed set and
that the SSL formula w.r.t. the partial order $\vdash$ is a 
complete lattice.
\end{block}
}


\subsection{Exporting into NTL format for verification step}

\frame{
\frametitle{Exporting the ECFG of a function into the NTL format}
\begin{itemize}
\item Assign to all $(sid,\phi)\in S$ an unique id $id_{sid,\phi}$.
\item Input state $IdS_i=\{id_{s_0,\phi_{enty}}\}$.
\item Error states : $IdS_{err}=\lbrace id_{s,\phi} | \phi = \bot \rbrace$.
\item States : $IdS = \lbrace id_{s,\phi} | (s,\phi) \not\in(S_i \cup S_f \cup S_{err})\rbrace$
\item Transitions : 
  \begin{itemize}
  \item For all $\tred{(s,\phi)}\times R \tgreen{(q,\psi)} \in \to$ do :
  \item Print $\tred{id_{s,\phi}}\to\tgreen{id_{q,\psi}} \{R\}$
 \end{itemize}
\end{itemize}



}

\frame{
\frametitle{Among other things}
\begin{itemize}
\item Validity of integer values : Initialization, difference
between two pointers, (Valid, Not Valid, Don't Know)
\item Transitions not generated when guards can be statically
proved false.
\end{itemize}

}


\frame{
\frametitle{Verification Phase : Reachability Analysis}

\begin{itemize}
\item Exporting the Ecfg Hierarchical Numerical Transition System.
\item Reachability analisys of the error states by FLATA and/or ELDARICA
\item If some error state is reachable : An alarm is raised.
\item If no error states is reachable : The program is free of the memory fault we consider. 
\end{itemize}
}

%\fram
%\frame{
%\frametitle{How to label terms with A.P. ?}
%\begin{center}
%\resizebox{10cm}{!}{\input{LabelLucas.pstex_t}}
%\end{center}
%}
%
%\frame{
%\frametitle{Precision of computational sets}
%\begin{center}
%\resizebox{8cm}{!}{\input{Precision.pstex_t}}
%\end{center}
%}
%

\end{document}

