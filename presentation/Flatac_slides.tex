%\include{commands}

\documentclass[compress]{beamer}
%\documentclass{beamer}

\usepackage{beamerthemeJuanLesPins}
\usepackage{amsfonts,amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{listings}

\usepackage[latin1]{inputenc}
%\usepackage{dcpic,pictex} %for commutative diagrams

\newcommand\xor{\oplus}
\newcommand{\emath}[1]{\ensuremath{#1}}
  \newcommand\tred[1]{\textcolor{red}{#1}}
  \newcommand\tblue[1]{\textcolor{blue}{#1}}
\newcommand\tgreen[1]{\textcolor{green}{#1}}
%\newcommand\tred[1]{\textcolor{red}{#1}}
%\usepackage[small,nhug,heads=vee]{diagrams}
%\diagramstyle[labelstyle=\scriptstyle]

\input{macro_filip}

%%%%%%%%%%%%%%%%%%%%%%  SSL RELATED STUFFS %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\bi}[1]{{}^\omega\!{#1}^\omega}
\newcommand{\rbr}{{\bf ]\!]}}
\newcommand{\lbr}{{\bf [\![}}


\newcommand{\sem}[1]{\lbr #1 \rbr}

\newcommand{\arrow}[2]{\xrightarrow[{\scriptstyle #2}]{{\scriptstyle #1}}}

\newcommand{\defeq}[0]{:=}
\newcommand{\syntaxeq}[0]{::=}

\newcommand{\Dom}[1]{\mathcal{D}om(#1)}

\newcommand{\rrule}[2]{\lstinline!#1!  \to \lstinline!#2!}
\newcommand\Addr{\mathcal{A}ddr} %The set of heap addresses
\newcommand\LVar{\mathcal{L}Var} %The set of location variables
\newcommand\PVar{\mathcal{P}Var} %The set of pointer variables.

\newcommand{\Pp}[1]{PP(#1)} %% The set of the atomic propositions that appear inside a formula.
\newcommand{\Sp}[1]{SP(#1)} %% The set of spacial propositions that appear insde a formula.


%Size of a formula.
\newcommand{\sizef}[1]{|{#1}|}
%subformula
\newcommand{\subf}[0]{\triangleright}

\newcommand{\gton}[1]{>_{#1}}
\newcommand{\gtlvar}[0]{\gton{\LVar}}
\newcommand{\gtptrvar}[0]{\gton{\PVar}}

\newcommand{\Locvar}[1]{Locvar(#1)} %The set of location variables appearing
	%in a formula
\newcommand{\Ptrvar}[1]{Ptrvar(#1)} %same as abovem but for Ptr variables.

\newcommand{\NULL}[0]{\mbox{\texttt{NULL}}}

\newcommand{\Alloc}[1]{alloc(#1)}
\newcommand{\Emp}{\lstinline{Emp}}

\newcommand{\Unsep}[0]{\ast}
\newcommand{\Sep}[2]{#1 \Unsep #2}
\newcommand{\Sepf}[2]{ #1 \star #2}

\newcommand{\EqLoc}[2]{ (#1 = #2) }
\newcommand{\Andpure}[2]{ #1 \wedge #2}
\newcommand{\Pointsto}[2]{ #1 \mapsto #2}
\newcommand{\nil}[0]{\lstinline!nil!}
\newcommand{\Pointstonil}[1]{ #1 \mapsto \mbox{\nil}}
\newcommand{\Formula}[2]{ #1  \updownarrow #2}
\newcommand{\Exists}[2]{ \exists #1. #2}

\newcommand{\Substin}[3]{#1\lbrack #2 \gets #3 \rbrack}
\newcommand{\NForm}[1]{\mathcal{NF}(#1)}

\newcommand{\Ran}[1]{\mathcal{R}an(#1)}

\newcommand{\Vars}[1]{\mathcal{V}ars(#1)}
\newcommand{\FVars}[1]{\mathcal{F}Vars(#1)}


\newcommand{\Equa}[1]{\mathcal{E}q(#1)}
\newcommand{\Aff}[1]{\mathcal{A}ff{#1}}
\newcommand{\Nullptr}[1]{\mathcal{N}ullptr{#1}}


\newcommand{\Subst}[3]{#3\lbrack #1\leftarrow #2 \rbrack}
\newcommand{\fundec}[5]{\begin{array}{llll} {#1}:&{#2} &\mapsto & {#3} \\ &{#4} & \mapsto& #5  \end{array}}


% add/replaces A.P. #2 in formula #1.
\newcommand{\Addrep}[2]{#1 \lbrack #2 \rbrack}


%%%%%%%%%%% Compute new name for existential variables %%%%%%%%

\newcommand{\renfresh}[2]{Renfresh(#1,#2)}



%%%%%%%%%% Order Relation %%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\LocOrderIneq}[0]{\sqsubset_{I}}
\newcommand{\LocOrderIeq}[0]{\sqsubseteq_{I}}
\newcommand{\PtrOrderIneq}[0]{\sqsubset_{S}}
\newcommand{\PtrOrderIeq}[0]{\sqsubseteq_{S}}
\newcommand{\ModOrderIeq}[0]{\sqsubseteq_{I,S}}
\newcommand{\ModOrderIneq}[0]{\sqsubset_{I,S}}


\newcommand{\true}{true}
\newcommand{\false}{false}
\newcommand{\dk}{dk}
%% #1 var name, #2 base, size, #4 offset
\newcommand{\ptrexp}[3]{\left ( \begin{array}{l} 
\ptrbase{#1}=#2 \\ 
\ptroffset{#1}=#3
\end{array} \right )}


\newcommand{\base}[2]{base_{#1}(#2)}
\newcommand{\samebase}[3]{Same\_base_{#1}({#2},{#3})}

\newcommand{\lbase}[1]{#1_{base}}
\newcommand{\lsize}[1]{#1_{size}}

\newcommand{\locvar}[3]{
\left ( \begin{array}{l}
\lbase{#1}=#2 \\
\lsize{#1}=#3
\end{array} \right )
}
%%%%%%%%%%%%% Hoar triples and sematic transformations %%%%%%%%%%%%%%%%%

%     instr  
% {P} -----> {Q}
%     effect
\newcommand{\transmodel}[4]{\lbrace #1 \rbrace \arrow{#2}{#3} \lbrace #4 \rbrace }

\newcommand{\Pre}[0]{\lbrace P \rbrace}
\newcommand{\Post}[0]{\lbrace Q \rbrace}

%%%%%%%%%%%% Footprint related stuff %%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\newcommand{\ptrbase}[1]{{#1}_{base}}
\newcommand{\ptrsize}[1]{{#1}_{size}}
\newcommand{\ptroffset}[1]{{#1}_{off}}
\newcommand{\gmallocid}[0]{mid}


\newcommand{\interpretZ}[1]{\sem{#1}_{\mathbb{Z}}}
\newcommand{\interpretI}[1]{\sem{#1}_{I}}
\newcommand{\interpretP}[1]{\sem{#1}_{P}}
\newcommand{\interpretC}[1]{\sem{#1}_{C}}

\newcommand{\Eval}[1]{Eval(#1)}

%%%%%%%%%%%%%%%%%%% Validity interpretation compters 
\newcommand{\ival}[1]{{#1}_{\mbox{valid}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inline text typology and other short notation definitions        %

\newcommand{\nth}[1]{$#1^{\mbox{th}}$}
\newcommand{\rd}[1]{$#1^{\mbox{rd}}$}


\newcommand{\syneq}[0]{::=} %Syntatic definition
\newcommand{\seq}[0]{\equiv} %Syntactic equality/equivalence

%%%%%%%%% Arithmetic operations
\newcommand{\intval}[2]{\left ( \begin{array}{l} #1 \\ #2 \end{array} \right )}

\newcommand{\valid}[1]{{#1}_{\mbox{\lstinline!valid!}}}
\newcommand{\intptr}[2]{\left ( \begin{array}{l} {#1} \\ {#2} 

\end{array} \right )}

\newcommand{\segfault}[0]{\mbox{\lstinline!segfault!}}

\newcommand{\andmath}[0]{\mbox{and}}
\newcommand{\congmod}[3]{#1 \equiv #2 \lbrack #3 \rbrack}
\newcommand{\notcongmod}[3]{#1 \not\equiv #2 \lbrack #3 \rbrack}
\newcommand{\isvalid}[2]{Valid_{#1}(#2)}
\newcommand{\DK}[2]{DK_{#1}(#2)}
%\newcommand{\interpa}[2]{Tr_{#1}(#2)}
\newcommand{\interpa}[2]{\sem{#2}_{#1}}

\newcommand{\interpacomp}[2]{Comp_{#1}(#2)}
\newcommand{\FRAMAC}{FRAMA-C}
\newcommand{\sizeof}[1]{\mbox{\lstinline!sizeof!}(#1)}

%% Counter associated to an interger variable.
\newcommand{\icnt}[1]{#1_{\mbox{cnt}}}

%% Access to memory @ pointer address P :
\newcommand{\accs}[1]{\mbox{\lstinline!access!}(#1)}

\newcommand{\clisting}[1]{\begin{lstlisting}[language=C,basicstyle=\ttfamily,keywordstyle=\color{red}] {#1} \end{lstlisting}}

%%%%%%%%%%%%%%%%%% SSL RELATED STUFFS END BLOCK %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
  
  

%  \newcommand\bo[1]{\mathcal{#1}}
%  \newcommand\mA{\bo{A}}
%  \newcommand\terminemachin{+a.s. }
%  \newcommand\truc\terminemachin
%  \newtheorem{proposition}{Proposition}
%  \newtheorem{condition}{Condition}
%  \newtheorem{exemple}{Exemple}
%  \newtheorem{theoreme}{Theorème}
%
%  \newtheorem{notation}{Notation}
%  \newcommand\notat[2]{\begin{condition}[#1] #2 \end{condition}}
%
%  \newcommand\cond[2]{\begin{condition}[#1] #2 \end{condition}}
%  \newtheorem{remarque}{Remarque}
  \usepackage{latexsym}
  \usepackage{graphicx}

%\input{../macros}

  \title{The Flatac Frama-c front-end}
 % \part{Main}


  \author{Radu Iosif, Florent Garnier}

\begin{document}
\frame{\titlepage 
}

\date{Febuary 2013}
%\part{Main}


\begin{frame}
\frametitle{Outline}
 \tableofcontents[pausesections]
\end{frame}



\section{Introduction }


\subsection{Motivations : Proving memory faults freedom of C programs}

\frame{
\frametitle{Classical memory faults :}
\begin{block}{}
\begin{itemize}
\item Memory access outside and allocated memory zone of the heap 
\item Access to an array outside of its bounds
\item Memory access using a non aligned address
\item Double free
\item Freeing an allocated segment using an pointer that does not points at the begining of the segment.
\item Memory leaks
\end{itemize}
\end{block}
}


\frame{
\frametitle{Two subkinds of properties :}
\begin{block}{Shape}
\begin{itemize}
  \item Relation between pointer variables (Stack) and location variables (heaps).
  \item Memory allocation.
  \item Allocated Segment separation.

  \end{itemize}
\end{block}

\begin{block}{Arithmetic properties}
  \begin{itemize}
  \item Memory segment access within its bounds. 
  \item Memory address alignment (Congruence).
  \item Calling on the begining of an allocated segment.
  \end{itemize}
\end{block}
}


\begin{frame}[fragile]{Verifying Heap Consistancy}
\setbeamercolor{alerted text}{fg=blue}
\setbeamerfont{alerted text}{series=\bfseries,family=\ttfamily}

\begin{block}{Errors tractable by shape analysis}
\begin{semiverbatim}
 void foo()\{
   char *x, *y;
   \uncover<2->{\alert<2->{ \{ emp \}}}
   x=malloc(10);
   \uncover<3->{\alert<3->{ \{ x->l | Alloc(l) \}}}
   y=x;
   \uncover<4->{\alert<4->{ \{ x->l and y-> l | Alloc(l) \}}}
   free(x);
   \uncover<5->{\alert<5->{ \{ x->l and y-> l | emp \}}}
   free(y);
   \uncover<6->{\alert<6->{ \{ error \}}}
 \}
\end{semiverbatim}
\end{block}
\end{frame}


\begin{frame}[fragile]{Verifying Heap Consistancy}
\setbeamercolor{alerted text}{fg=blue}
\setbeamerfont{alerted text}{series=\bfseries,family=\ttfamily}
\begin{block}{Shape is not enough}
\begin{semiverbatim}
 void foo()\{
   char *x, *y;
   \uncover<2->{\alert<2->{ \{ emp \}}}
   x=malloc(10);
   \uncover<3->{\alert<3->{ \{ x->l | Alloc(l) \}}}
   x++;
   \uncover<4->{\alert<4->{ \{ x->l | Alloc(l) \}}}
   free(x);
   \only<5>{\alert<5>{ \{ x->l | emp \}}} \only<6>{\alert<6>{ \{error\} }}
  
 \}
\end{semiverbatim}
\end{block}
\end{frame}




%\defverbatim[colored]\lstH1{


%}


%\begin{frame}[fragile]
%\frametitle{trying another way ...}

 %\begin{lstlisting}[language=C,basicstyle=\ttfamily,keywordstyle=\color{red}]
 %  void foo(){
 %    char *x, *y;
% \clisting{void foo(){
 %    char *x, *y;
  % } }
%\end{frame}


\frame{
\frametitle{A better suited model}
\begin{block}{Shape and arithmetic properties}
\begin{center}
\includegraphics[width=0.4\textwidth]{align.eps}
\end{center}
\end{block}
}



\section{Abstract reprentation of the memory}
\subsection{The SSL logic : Decribing the Shape}

\frame{
\frametitle{Abstract interpretation preliminary part}
 Simple Separation Logic formulae : Abstract domain.

\begin{block}{Syntax of SSL}
$$
\begin{array}{lclr}
\phi & := & \Formula{\pi}{\sigma} \gspace | \gspace \Exists{l}{\phi} & \mbox{Formulae} \\
\pi & := & \Pointsto{x}{l} \gspace | \gspace \Pointstonil{x} \gspace | \gspace \EqLoc{l_1}{l_2} \gspace | \gspace \Andpure{\pi_1}{\pi_2} & {\mbox{Pure part}} \\
\sigma &:=& \Emp  \gspace | \gspace \Alloc{l} \gspace | \gspace \Sep{\sigma_1}{\sigma_2}\ \gspace | \gspace \bot & \mbox{Spatial part}
\end{array}
$$
\end{block}
}


\frame{
\frametitle{Good properties of SSL}
\begin{block}{Properties}
The problem that follows are decidable :
\begin{itemize}
\item Satisfiability (Valid configuration)
\item Entailment, Equivalence (Fix point detection).
\item Memory leaks
\end{itemize}
\end{block}

Those problems are solved using rewriting techniques.
}


\frame{
\frametitle{Numerical Transition Language}
\begin{block}{Allows express and define:}
\begin{itemize}
 \item Basic types: bool, int, real
 \item Control states: initial, final, error
 \item Transitions: first-order arithemtic
 \item Multi dimesional arrays
 \item Hierarchy: (recursive) function calls
 \item Shared memory concurrency
\end{itemize}

Models are expressed in this language.
\end{block}

}

\subsection{What is flatac}
\frame{
\begin{block}{What is flatac ?}
\begin{itemize}
\item Takes as input a C Program description using FRAMA-C/Cil AST and CFG.
\item Extracts a NTS base model of the program using static analysis techniques.

 \item \begin{itemize}
    \item Control states having an unsat SSL formula are error states.
    \item Return control states having a sat SSL formula are final.
    \item Entry point of function are initial states.
  \end{itemize}
\item Exports this model in the NTL format.
 \end{itemize}
\end{block}

\begin{block}{Goal}
\begin{itemize}
\item Query Verification tools for the Reachability of error states.
\item Termination.
\end{itemize}

 Coded as a Frama-C plugin. 
\end{block}
}



%\frame{
%\begin{center}
%\includegraphics[angle=270,width=0.8\textwidth]{torino-24.pdf}
%\end{center}
%}


%\defverbatim[colored]\lstI{%
%\begin{lstlisting}[language=C,basicstyle=\ttfamily,keywordstyle=\color{red}] 
%void foo(){
% char *x, *y;
% \uncover<1>{Emp}
% x=malloc(10);
% %\uncover<2>{ x-\>l /\ Alloc(l)}
% y=x;
% free(x);
% free(y;)
%}
%\end{lstlisting}
%}



%\begin{frame}{Verifying Heap Consistency}
%\lstI
%\end{frame}






%\frame{
%\frametitle{Tracked property}
%\begin{block}{ Checking that C programs:}
%\begin{itemize}
%\item have no execution run that lead to memory fault,
%\item have no exectution that violates some assertion expressed.
%using arithmetic constraints.
%\end{itemize}
%\tgreen{A verification front-end. }
%\begin{itemize}
%\item Extracts models of C Programs using Abstract Interpretation Techniques. 
%\item Adds \tred{Numerical Transitions Systems} informations on the
%model for \tred{a posteriori Verification Phase}.  
%\item Exports the model into the NTL language.
%\end{itemize}
%\end{block}
%}


%\frame{
%\frametitle{}
%\begin{enumerate}
%\item Extracting an extended cfg from Frama-c cfg $($Cil statements $\times$SSL memory abstractions$)^2$
%\item Labelling the Ecfg transitions with Numerical Transition System expression --Guards, counter affectation and Function Calls.
%\item If a SSL Abs value of a state is $\bot$, define this state as
%an error state.
%\item Export the labelled Ecfg into Nts Format.
%\item Ask an analysis tool --Flata, Eldarica, to check whether 
%some error state is reachable from the entry point (main function).

%\end{enumerate}

%}

\subsection{Flata-c a link in a toolchain}
\frame{
\frametitle{Flatac in the tool-chain:}
\begin{center}
\resizebox{9.5cm}{7cm}{\input{toolchain.pstex_t}}
\end{center}

}




%\frame{
%\frametitle{Example of SSL formulae}
%\begin{itemize}
%\item $\Formula{ \Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Emp}$
%\item $\Formula{\Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Alloc{l_1}}$
%\item $\Formula{ \Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Sep{\Alloc{l_1}}{\Alloc{l}}}$
%\item $\Formula{ \Andpure{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}{\Pointstonil{z}}}{\Sep{\Alloc{l_1}}{\Alloc{l}}}$
%\item $\Formula{ \Andpure{x=y}{\Andpure{\Pointsto{x}{l_1}}{\Pointsto{y}{l}}}}{\Sep{\Alloc{l_1}}{\Alloc{l}}}$ (Unsat)
%\item $\Formula{ \Andpure{x=y}{\Andpure{\Pointsto{x}{l_1}}{\Pointstonil{y}}}}{\Alloc{l_1}}$ (Unsat)
%\item $\Formula{ true }{\Alloc{l}}$ (Leak)
%\end{itemize}
%}
%

\subsection{Memory model}
\frame{
\frametitle{Flata-c Memory model}
A memory model that associates counters to SSL
variables :

\begin{block}{Additional quantitative informations}
$$
\begin{array}{lcr}
\mbox{SSL Variable} & \mbox{NTS counter} & \\
x\in PVar & \mbox{\texttt{x\_offset}} & \mbox{offset} \\
l\in LVar & \mbox{\texttt{l\_size}} & \mbox{segment size}
\end{array}
$$
In order to :
\begin{itemize}
\item Associate to segment their size.
\item Associate to pointer their offset.
\item To express guards on memory access.
\end{itemize}
\end{block}
}



\section{Model extraction}
\subsection{Cil representation of C programs}
\frame{
\frametitle{Cil representation of C programs}

Cil provides and AST and CFG info from C files.

\begin{block}{Most relevant information}
For each function of the AST :
\begin{itemize}
\item Expressions.
\item Locals and formal variables.
\item Statements of the Control flow graph.

\end{itemize}
\end{block}

}



\frame{
\frametitle{From cil statments to NTS}
\begin{center}
\resizebox{8cm}{!}{\input{Cilstatements.pstex_t}}
\end{center}
}


\subsection{Extraction steps}

\frame{
\frametitle{Step 1 : Compile expression + Valid mem conditions}
\begin{center}
\resizebox{8cm}{!}{\input{compilestep1.pstex_t}}
\end{center}
}


\frame{
\frametitle{Step 2 : Updating absdomain evaluation}
\begin{center}
\resizebox{8cm}{!}{\input{compilestep2.pstex_t}}
\end{center}
}

\frame{
\frametitle{Step 3 : Recurse on all abstract successors}
\begin{center}
\resizebox{8cm}{!}{\input{compilestep3.pstex_t}}
\end{center}
}


\frame{
\frametitle{Non deterministic evaluation : validity}
To any integer variable is associated a validity counter. An
expression is valid if it is the result of deterministic values.
\begin{block}{Basic rules}
\begin{tabular}{lll}
\texttt{int x;} & \texttt{valid\_x = false} \\
\texttt{int x=cst;} & \texttt{valid\_x = true} \\
\texttt{x=y;} & \texttt{valid\_x= valid\_y;} \\
\texttt{x=ptrw-ptrz;} & \texttt{true} &if $\Formula{\Pointsto{ptrw}{l}\wedge\Pointsto{ptrz}{l}}{.}$\\
& \texttt{false} &else
\end{tabular}
\end{block}

}

\frame{
\frametitle{Nts guards for safe memory access}

Let \texttt{x} a $PVar$ such that \texttt{x:}$\tau$\texttt{*}
Let $\texttt{safe\_mem}:\texttt{Cil\_types.expr}\times SSL \mapsto NtsGuards$

\begin{block}{Memory access guards Cil for atomic expressions}
\begin{tabular}{lcl}
Expr &Mem abstraction & Nts Guard \\ 
\texttt{*x} &$\Formula{\Pointsto{x}{l}}{\Alloc{l}}$ & \texttt{true}\\
\texttt{*x} &$\Formula{\Pointsto{x}{l}}{\Emp}$& \texttt{false}\\ 
\texttt{*(x+i)} & $\Formula{\Pointsto{x}{l}}{\Alloc{l}}$& \texttt{valid\_i}$\wedge 0\leq i\times$\texttt{sizeof(}$\tau$\texttt{)}$<$\texttt{l\_size}\\
\texttt{tab[i]}&$\Formula{true}{\Emp}$& \texttt{valid\_i}$\wedge 0\leq i <$ \texttt{tab\_size}\\
\end{tabular}
\end{block}
}


\frame{
\frametitle{Control flow statements v.s. basic instructions}

\begin{block}{Control flow statement}
One need to consider a transition to $\bot$ guarded by
$\neg$ \texttt{safe\_mem(expr)}.
\begin{itemize}
\item \texttt{if(expr,blockif,blockelse)}
\item \texttt{switch(expr,case\_list)}
\end{itemize}
\end{block}
Basic statement are easier to model.
\begin{block}{Instruction statement}
\begin{itemize}
\item \texttt{lval=expr}
\item \texttt{lval=funcall(name,exp list)}
\end{itemize}
\end{block}
}

\frame{
\frametitle{Model extraction :}

Input : Cil AST and Control flow graph

Generated Model : Extended CFG,
  


where :
\begin{itemize}
\item The verticies are statement id labelled with SSL formula.
\item The edges are labelled with Nts Guards, affectation, and
function calls.
\end{itemize}
}


\frame{
\frametitle{Extraction : Basic statment}

\begin{block}{\texttt{Var(v)=expr}}
\begin{center}
\resizebox{8cm}{!}{\input{affectvar.pstex_t}}
\end{center}

\end{block}
}



\frame{
\frametitle{Extraction : Basic statment}

\begin{block}{\texttt{lval=expr}}
Considered lvals are array element and referenced mem
cells. 
\begin{center}
\resizebox{8cm}{!}{\input{affectlval.pstex_t}}
\end{center}

\end{block}
}


\frame{
\frametitle{Extraction : Basic statement}
\begin{block}{\texttt{lval=call(fun,arg1},...,\texttt{argn)}}
Call of \texttt{fun} where \texttt{\{P\} fun \{Q\}}.
\begin{center}
\resizebox{7cm}{!}{\input{funcall.pstex_t}}
\end{center}

\end{block}
}


\frame{
\frametitle{Extraction : Control Flow operation}
\begin{block}{\texttt{if(test, stmtif, stmtelse)}}
Expression \texttt{test} might perform some illegal operations.
\begin{center}
\resizebox{5cm}{!}{\input{ifthen.pstex_t}}
\end{center}
\end{block}
}


\frame{
\frametitle{Extraction : Extended Cfg building algorithm}

When generating some $(sid_i,\psi_i)$ from the current abstract
state $(s,\phi)$, with label $R$ do:
\begin{itemize}
\item Create a new vertex $(sid_i,\psi_i)$ if $\psi_i$
is the most general formula associated to $sid_i$.
Create a new edge between the two vertex, with label $R$.
Recurse on $(sid_i,\psi_i)$
\item Else 
  \begin{itemize}
  \item Add an edge labelled R from the current state 
    to $(sid_i,\psi_g)$ with $\psi_g$ greatest element.
  \end{itemize}
\end{itemize}


}





\subsection{Exporting into NTL format for verification step}

\frame{
\frametitle{Verification Phase : Reachability Analysis}

\begin{itemize}
\item Exporting the Ecfg Hierarchical Numerical Transition System.
\item Reachability analisys of the error states by FLATA and/or ELDARICA
\item If some error state is reachable : An alarm is raised.
\item If no error states is reachable : The program is free of the memory fault we consider. 
\end{itemize}
}


%\section{Benchmarks}

%\frame{
%\frametitle{Benchmarks}

%\begin{figure}[h!]
%%\begin{scriptsize}
%{\small
%\begin{minipage}[t]{.5\textwidth}
%%\begin{scriptsize}
%\begin{tabular}[t]{lrrrr}
%\hline
%%\multirow{2}{*}{Model} & \multicolumn{2}{c}{ Time [s]} \\
%& F. & E. & S. & D. \\
%\hline
%\multicolumn{3}{l}{\textbf{(a) Examples from TACASO6\[\]}} \\
%\hline
%anubhav (C)  &  0.6  & 1.5 &  1.8  &  1.5\\
%copy1 (E)  &  1.7 & 8.1  &  1.2  &  3.5\\
%cousot (C) &  0.5 & -  &  -  &  4.3 \\
%loop1 (C) &  0.4 & 2.1  &  0.9  &  2.1 \\
%loop (C) &  0.4 & 0.3  &  0.9  &  0.3 \\
%scan  (E) &  2.4 & -  &  1.0  &  2.9 \\
%string\_concat1  (E) &  4.4  & -  &  3.2  &  5.0  \\
%string\_concat  (E) &  4.1  & -  &  2.5  &  4.2  \\
%string\_copy  (E) &  3.7  & -  &  1.5  &  3.6  \\
%substring1 (E) &  0.3  & 1.6  &  23.9  &  1.5 \\
%substring (E) &  1.8  & 0.6  &  1.6  &  0.6 \\
%\hline
%\end{tabular}
%\end{minipage}%
%\hspace*{-2ex}%
%} % end small
%\end{scriptsize}
%\end{figure}
%\textbf{F}lata, \textbf{E}ldarica, Eldarica (\textbf{S}tatic loop acceleration)
% and CEGAAR (\textbf{D}ynamic acceleration).  

%}


\frame{
\frametitle{Benchmarks}

\begin{figure}[h!]
%\begin{scriptsize}
{\small
\begin{minipage}[t]{.5\textwidth}
%\begin{scriptsize}
\begin{tabular}[t]{lrrrr}
\hline
%\multirow{2}{*}{Model} & \multicolumn{2}{c}{ Time [s]} \\
& F. & E. & S. & D. \\
\hline
\multicolumn{3}{l}{\textbf{ Examples from Monniaux}} \\
boustrophedon (C) &  -  & -  &  -  &  12.2 \\
gopan (C) &  0.5  & -  &  -  &  6.7 \\
halbwachs (C) & -  & -  &  1.6  &  8.2 \\
rate\_limiter (C) &  -  & 7.2  &  2.7  &  7.1 \\
\hline
\multicolumn{3}{l}{\textbf{(e) NECLA benchmarks}} \\
\hline
inf1 (E) &  0.1  & 0.3  &  0.3  &  0.3 \\
inf4 (E) &  0.8  & 0.5  &  0.5  &  0.5 \\
inf6 (C) & 0.1  & 0.3  &  0.3  &  0.3 \\
inf8 (C) &  0.3  & 0.6  &  0.6  &  0.6 \\
\hline
\end{tabular}
\end{minipage}%
\hspace*{-2ex}%
} % end small
%\end{scriptsize}
\end{figure}
\textbf{F}lata, \textbf{E}ldarica, Eldarica (\textbf{S}tatic loop acceleration)
 and CEGAAR (\textbf{D}ynamic acceleration).  

}
%\fram
%\frame{
%\frametitle{How to label terms with A.P. ?}
%\begin{center}
%\resizebox{10cm}{!}{\input{LabelLucas.pstex_t}}
%\end{center}
%}
%
%\frame{
%\frametitle{Precision of computational sets}
%\begin{center}
%\resizebox{8cm}{!}{\input{Precision.pstex_t}}
%\end{center}
%}
%

\end{document}

\frame{
\frametitle{Example}
$$
\begin{array}{lll}
\mbox{C "statement"} & \mbox{SSL formula}& \texttt{NTS transition} \\
\mbox{\texttt{int *x;}} &\Formula{\exists l \Pointsto{x}{l}}{\Emp}&\texttt{offset\_x'=0}\\
\mbox{\texttt{x=malloc(10);}} &\Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}&\texttt{size\_l=10}\\
\mbox{\texttt{x++;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=sizeof(int)} \\
\mbox{\texttt{int y =*x;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'} < \mbox{size\_l} \\
&\Formula{\exists . l \Pointsto{x}{l}}{\Alloc{l}}& \mbox{havoc(y)}
\end{array}
$$

}

\frame{
\frametitle{Example}
$$
\begin{array}{lll}
\mbox{C "statement"} & \mbox{SSL formula}& \texttt{NTS transition} \\
\mbox{\texttt{int *x;}} &\Formula{\exists l \Pointsto{x}{l}}{\Emp}&\texttt{offset\_x'=0}\\
\mbox{\texttt{x=malloc(10);}} &\Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}&\texttt{size\_l=10}\\
\mbox{\texttt{x++;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=sizeof(int)} \\
\mbox{\texttt{int y =*x;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'}<\mbox{size\_l} \\
&\Formula{\exists . l \Pointsto{x}{l}}{\Alloc{l}}& \mbox{havoc(y)}\\
\mbox{\texttt{x+=10;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=10*sizeof(int)} \\
\end{array}
$$
}



\frame{
\frametitle{Example}
$$
\begin{array}{lll}
\mbox{C "statement"} & \mbox{SSL formula}& \texttt{NTS transition} \\
\mbox{\texttt{int *x;}} &\Formula{\exists l \Pointsto{x}{l}}{\Emp}&\texttt{offset\_x'=0}\\
\mbox{\texttt{x=malloc(10);}} &\Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}&\texttt{size\_l=10}\\
\mbox{\texttt{x++;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=sizeof(int)} \\
\mbox{\texttt{int y =*x;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'}<\mbox{size\_l} \\
&\Formula{\exists . l \Pointsto{x}{l}}{\Alloc{l}}& \mbox{havoc(y)}\\
\mbox{\texttt{x+=10;}} & \Formula{\exists l \Pointsto{x}{l}}{\Alloc{l}}& \texttt{offset\_x'+=10*sizeof(int)} \\
\mbox{\texttt{*x=42;}} & \bot & \tred{\texttt{offset\_x}\geq\mbox{size\_l}} \\
\end{array}
$$

\tred{Access to \texttt{*x} is out of bounds of allocated segment at \texttt{l}.}
}


\frame{
\frametitle{Compiling expressions}


\begin{block}{From pointer arithmetics to Nts expressions}
$$
\begin{array}{|lll|}
\hline
\base{\phi}{x}&:=& l \mbox{ if }  \Pointsto{x}{l} \in \Pp{\phi} \\
\base{\phi}{\NULL} &:=& \nil \gspace \forall \phi \\
\base{\phi}{P+I} &:=& \base{\phi}{P} \\

%\end{array}
%$$


%}

%\frame{
%\frametitle{Compiling Integer expressions}

%$$
%\begin{array}{|lll|}
 \interpa{\phi}{n} & := & n \\
\interpa{\phi}{i} & := & \icnt{i} \\
\interpa{\phi}{\NULL} & := & 0 \\
\interpa{\phi}{x} &:=& \ptroffset{x} \\
\interpa{\phi}{x_1 - x_2} & :=&  \ptroffset{x_1}-\ptroffset{x_2} \\
\interpa{\phi}{P+I} & := & \interpa{\phi}{P}+\interpa{\phi}{I}\times \sizeof{\tau}, \mbox{ where } P:\tau *\\
\interpa{\phi}{P_1 - P_2} & := & ( \interpa{\phi}{P_1}-\interpa{\phi}{P_2}) / \sizeof{\tau}, \mbox{ where } P_1:\tau * \\
\interpa{\phi}{I_1+I_2} &:=& \interpa{\phi}{I_1} + \interpa{\phi}{I_2} \\
\interpa{\phi}{I_1 \times I_2} &:= &\interpa{\phi}{I_1} \times \interpa{\phi}{I_2} \\
\hline
\end{array}
$$
\end{block}
}


\frame{
\frametitle{Compiling booleans to Nts guards}

\begin{block}{}
$$
\begin{array}{lll}

\interpa{\phi}{P_1 == P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} == \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\
&&\\
\interpa{\phi}{P_1 != P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} != \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\
&&\\
\interpa{\phi}{P_1 \bowtie P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} \bowtie \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\ 
\end{array}
$$
\end{block}
}


\frame{
\frametitle{Compiling expressions}


\begin{block}{From pointer arithmetics to Nts expressions}
$$
\begin{array}{|lll|}
\hline
\base{\phi}{x}&:=& l \mbox{ if }  \Pointsto{x}{l} \in \Pp{\phi} \\
\base{\phi}{\NULL} &:=& \nil \gspace \forall \phi \\
\base{\phi}{P+I} &:=& \base{\phi}{P} \\

%\end{array}
%$$


%}

%\frame{
%\frametitle{Compiling Integer expressions}

%$$
%\begin{array}{|lll|}
 \interpa{\phi}{n} & := & n \\
\interpa{\phi}{i} & := & \icnt{i} \\
\interpa{\phi}{\NULL} & := & 0 \\
\interpa{\phi}{x} &:=& \ptroffset{x} \\
\interpa{\phi}{x_1 - x_2} & :=&  \ptroffset{x_1}-\ptroffset{x_2} \\
\interpa{\phi}{P+I} & := & \interpa{\phi}{P}+\interpa{\phi}{I}\times \sizeof{\tau}, \mbox{ where } P:\tau *\\
\interpa{\phi}{P_1 - P_2} & := & ( \interpa{\phi}{P_1}-\interpa{\phi}{P_2}) / \sizeof{\tau}, \mbox{ where } P_1:\tau * \\
\interpa{\phi}{I_1+I_2} &:=& \interpa{\phi}{I_1} + \interpa{\phi}{I_2} \\
\interpa{\phi}{I_1 \times I_2} &:= &\interpa{\phi}{I_1} \times \interpa{\phi}{I
_2} \\
\hline
\end{array}
$$
\end{block}
}


\frame{
\frametitle{Compiling booleans to Nts guards}

\begin{block}{}
$$
\begin{array}{lll}

\interpa{\phi}{P_1 == P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} == \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\
&&\\
\interpa{\phi}{P_1 != P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} != \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\
&&\\
\interpa{\phi}{P_1 \bowtie P_2} &:=& \left \lbrace \begin{array}{ll} 
        \interpa{\phi}{P_1} \bowtie \interpa{\phi}{P_2} & \mbox{ if } \base{\phi}{P_1}\seq\base{\phi}{P_2} \\
        \bot & \mbox{else} 
        \end{array} \right . \\ 
\end{array}
$$
\end{block}
}

\frame{
\frametitle{Extraction : Extended Cfg building algorithm}

\begin{itemize}
\item If $\exists (sid,\psi)\in S$ s.t. $sid=s_{next}$ and $\psi\vdash\phi$
then $\to = \to \cup (s_{curr},\phi),R,(s_{next},\psi)$
\item Else 
  \begin{itemize}
  \item $\to = \to \cup (s_{curr},\phi),R,(s_{next},\phi^{\prime})$
  \item Recurse on abstract state $(s_{next},\phi^{\prime})$
  \end{itemize}
\end{itemize}

\begin{block}{Termination}
This algorith terminates as the $sid$ index is a fixed set and
that the SSL formula w.r.t. the partial order $\vdash$ is a 
complete lattice.
\end{block}
}


\frame{
\frametitle{Nts guards for safe memory access}
\begin{block}{Cil expression type definition (Non exhaustive)}
\begin{tabular}{l}
\texttt{UnOp(UOp,expr)} \\
\texttt{BinOp(BOp,expg,expd)}\\
\texttt{UOP}=\texttt{UnMin| BNot | Neg}$\ldots$ \\
\texttt{BOP}=\texttt{BAnd|BOr}$\ldots$\\
\phantom{UOP}\texttt{Plus|Minus|Prod|Div}$\ldots$\\
\phantom{BOP}\texttt{PlusPI|MinusPI|MinusPP}$\ldots$\\
\end{tabular}
\end{block}

\begin{block}{\texttt{valid\_mem} of Cil expression}
\begin{tabular}{ll}
Cil expr & \texttt{valid\_mem} \\
\texttt{UnOp(UOp,expr)} & \texttt{valid\_mem(expr)}\\
\texttt{BinOp(BOp,expg,expd)} & \texttt{valid\_mem(expg)}$\wedge$\texttt{valid\_mem(expg)} \\
\end{tabular}
\end{block}
}



%\frame{
%\frametitle{Exporting the ECFG of a function into the NTL format}
%\begin{itemize}
%\item Assign to all $(sid,\phi)\in S$ an unique id $id_{sid,\phi}$.
%\item Input state $IdS_i=\{id_{s_0,\phi_{enty}}\}$.
%\item Error states : $IdS_{err}=\lbrace id_{s,\phi} | \phi = \bot \rbrace$.
%\item States : $IdS = \lbrace id_{s,\phi} | (s,\phi) \not\in(S_i \cup S_f \cup S_{err})\rbrace$
%\item Transitions : 
%  \begin{itemize}
%  \item For all $\tred{(s,\phi)}\times R \tgreen{(q,\psi)} \in \to$ do :
%  \item Print $\tred{id_{s,\phi}}\to\tgreen{id_{q,\psi}} \{R\}$
% \end{itemize}
%\end{itemize}



%}
